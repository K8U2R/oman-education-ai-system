import OpenAI from 'openai';
import { IAIProvider, AICompletionOptions, AIChatRequest, AICompletionResponse, AICodeGenerationRequest, AICodeGenerationResponse } from '@/domain/interfaces/ai/IAIProvider.js';
import { ENV_CONFIG } from '@/infrastructure/config/env.config.js';
import { logger } from '@/shared/utils/logger.js';

export class OpenAIAdapter implements IAIProvider {
  private client: OpenAI;
  private readonly MAX_RETRIES = 3;

  constructor() {
    if (!ENV_CONFIG.OPENAI_API_KEY) {
      logger.warn("⚠️ OpenAI API Key missing! AI features will fail.");
    }
    this.client = new OpenAI({
      apiKey: ENV_CONFIG.OPENAI_API_KEY,
    });
  }
  async connect(config: { apiKey: string; defaultModel?: string }): Promise<void> {
    if (!config.apiKey) throw new Error("API Key required for OpenAI");
    // Client already initialized in constructor but we can re-init or validate here
    return;
  }

  // Added methods to satisfy the "Rich" IAIProvider interface used by AIProviderFactory/Education Service

  async chatCompletion(request: AIChatRequest): Promise<AICompletionResponse> {
    return this.retryOperation(async () => {
      const response = await this.client.chat.completions.create({
        model: request.model || "gpt-4o",
        messages: request.messages,
        temperature: request.temperature || 0.7,
        max_tokens: request.maxTokens || 1000
      });

      const content = response.choices[0]?.message?.content || "";
      const usage = response.usage ? {
        promptTokens: response.usage.prompt_tokens,
        completionTokens: response.usage.completion_tokens,
        totalTokens: response.usage.total_tokens
      } : undefined;

      return {
        content,
        model: response.model,
        usage
      };
    });
  }

  async generateCode(request: AICodeGenerationRequest): Promise<AICodeGenerationResponse> {
    return this.retryOperation(async () => {
      const prompt = `Write code for: ${request.prompt}\nLanguage: ${request.language || 'typescript'}\nFramework: ${request.framework || 'express'}\nContext: ${request.context || ''}`;
      const response = await this.client.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: "You are an expert coding assistant." },
          { role: "user", content: prompt }
        ],
        temperature: 0.2
      });
      return {
        code: response.choices[0]?.message?.content || "",
        explanation: "Generated by AI",
        language: request.language,
        framework: request.framework
      };
    });
  }

  async generateEmbedding(_text: string): Promise<number[]> {
    // Stub or implement
    return [0.1, 0.2, 0.3];
  }

  async healthCheck(): Promise<string> {
    const healthy = await this.checkHealth();
    return healthy ? "healthy" : "unhealthy";
  }

  getName(): string {
    return "openai";
  }

  // Existing methods...
  async generateText(prompt: string, options?: AICompletionOptions): Promise<string> {
    return this.retryOperation(async () => {
      const response = await this.client.chat.completions.create({
        model: "gpt-4o", // Or gpt-3.5-turbo depending on budget
        messages: [
          { role: "system", content: options?.systemPrompt || "You are a helpful education assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options?.temperature || 0.7,
        max_tokens: options?.maxTokens || 1000,
      });

      return response.choices[0]?.message?.content || "";
    });
  }

  async generateJson<T>(prompt: string, schema: object, options?: AICompletionOptions): Promise<T> {
    return this.retryOperation(async () => {
      const response = await this.client.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: options?.systemPrompt || "You are a strict JSON generator. Output only valid JSON matching the schema." },
          { role: "user", content: `Schema: ${JSON.stringify(schema)}\n\nRequest: ${prompt}` }
        ],
        response_format: { type: "json_object" },
        temperature: 0.2, // Lower temp for strict structure
      });

      const content = response.choices[0]?.message?.content;
      if (!content) throw new Error("Empty AI response");

      try {
        return JSON.parse(content) as T;
      } catch (_e) {
        logger.error("Failed to parse AI JSON", { content });
        throw new Error("Invalid JSON Response from AI");
      }
    });
  }

  async checkHealth(): Promise<boolean> {
    try {
      await this.client.models.list();
      return true;
    } catch (_e) {
      return false;
    }
  }

  private async retryOperation<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: unknown;

    for (let i = 0; i < this.MAX_RETRIES; i++) {
      try {
        return await operation();
      } catch (error: unknown) {
        lastError = error;
        // Retry only on 429 (Rate Limit) or 5xx (Server Error)
        const status = (error as { status?: number })?.status;
        if (status === 429 || (status && status >= 500)) {
          const delay = Math.pow(2, i) * 1000; // Exponential backoff: 1s, 2s, 4s
          logger.warn(`AI Provider Error (Attempt ${i + 1}/${this.MAX_RETRIES}). Retrying in ${delay}ms...`, { error: (error as Error).message });
          await new Promise(r => setTimeout(r, delay));
          continue;
        }
        // Don't retry client errors (400)
        throw error;
      }
    }

    // Law 08 (Fail-Safe)
    logger.error("AI Provider Fatal Error after retries", { error: lastError });
    const errorMessage = lastError instanceof Error ? lastError.message : 'Unknown Error';
    throw new Error(`AI Provider Unavailable: ${errorMessage}`);
  }
}

