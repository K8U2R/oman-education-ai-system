import { EnhancedBaseService } from "@/application/services/system/base/EnhancedBaseService.js";
import { DatabaseCoreAdapter } from "@/infrastructure/adapters/db/DatabaseCoreAdapter.js";
import { GoogleProfile } from "@/domain/types/auth/index.js";
import { AppError } from "@/core/errors/AppError.js";
import { logger } from "@/shared/utils/logger.js";
import axios from "axios";
import { AuthConfig } from "../../config/auth.config.js";
import { inject } from "tsyringe";
import { IGoogleOAuthRepository } from "@/domain/interfaces/repositories/auth/social/IGoogleOAuthRepository.js";
import { TokenService } from "../identity/TokenService.js";
import { AuthTokens } from "@/domain/types/auth/index.js";
import { GoogleUserInfo } from "@/domain/value-objects/GoogleUserInfo.js";

export class GoogleOAuthService extends EnhancedBaseService {
  private readonly clientId: string;
  private readonly clientSecret: string;
  private readonly callbackUrl: string;

  constructor(
    databaseAdapter: DatabaseCoreAdapter,
    @inject("AuthConfig") config: AuthConfig,
    @inject("IGoogleOAuthRepository")
    private readonly googleOAuthRepository: IGoogleOAuthRepository,
    @inject("TokenService") private readonly tokenService: TokenService,
  ) {
    super(databaseAdapter);
    this.clientId = config.google.clientId;
    this.clientSecret = config.google.clientSecret;
    this.callbackUrl = config.google.callbackUrl;

    if (!this.clientId || !this.clientSecret) {
      logger.warn(
        "Google OAuth credentials missing in AuthConfig. OAuth features will be unavailable.",
      );
    }
  }

  protected getServiceName(): string {
    return "GoogleOAuthService";
  }

  /**
   * Generate Authorization URL
   *
   * @param state - Secure random state token (generated by OAuthStateService)
   * @returns Google OAuth URL
   */
  async generateAuthorizationUrl(state: string): Promise<string> {
    return this.executeWithEnhancements(
      async () => {
        if (!this.clientId) {
          throw new AppError(
            "Google OAuth is not configured",
            "OAUTH_NOT_CONFIGURED",
            500,
          );
        }

        if (!state) {
          throw new AppError("State token is required", "INVALID_STATE", 400);
        }

        const scopes = [
          "https://www.googleapis.com/auth/userinfo.profile",
          "https://www.googleapis.com/auth/userinfo.email",
        ];

        const url = new URL("https://accounts.google.com/o/oauth2/v2/auth");
        url.searchParams.append("client_id", this.clientId);
        url.searchParams.append("redirect_uri", this.callbackUrl);
        url.searchParams.append("response_type", "code");
        url.searchParams.append("scope", scopes.join(" "));
        url.searchParams.append("state", state);
        url.searchParams.append("access_type", "offline");
        url.searchParams.append("prompt", "consent");

        return url.toString();
      },
      { retryable: false },
      { operation: "generateAuthorizationUrl" },
    );
  }

  /**
   * Handle OAuth Callback
   *
   * @param code - Authorization code
   * @returns AuthTokens & User Profile
   */
  async handleCallback(
    code: string,
  ): Promise<{ tokens: AuthTokens; user: GoogleProfile }> {
    return this.executeWithEnhancements(
      async () => {
        if (!code) {
          throw new AppError(
            "Authorization code is required",
            "MISSING_CODE",
            400,
          );
        }

        if (!this.clientId || !this.clientSecret) {
          throw new AppError(
            "Google OAuth is not configured",
            "OAUTH_NOT_CONFIGURED",
            500,
          );
        }

        // 1. Exchange code for Google tokens
        const tokenResponse = await axios.post(
          "https://oauth2.googleapis.com/token",
          {
            code,
            client_id: this.clientId,
            client_secret: this.clientSecret,
            redirect_uri: this.callbackUrl,
            grant_type: "authorization_code",
          },
        );

        const { access_token } = tokenResponse.data;

        // 2. Fetch user profile from Google
        const profileResponse = await axios.get(
          "https://www.googleapis.com/oauth2/v3/userinfo",
          {
            headers: { Authorization: `Bearer ${access_token}` },
          },
        );

        const userData = profileResponse.data;

        const googleProfile: GoogleProfile = {
          id: userData.sub,
          email: userData.email,
          name: userData.name,
          picture: userData.picture,
          given_name: userData.given_name,
          family_name: userData.family_name,
          verified_email: userData.email_verified,
        };

        // 3. Persist User (Create or Update)
        // This is the CRITICAL fix: Saving the user to our DB
        const user = await this.googleOAuthRepository.createUserFromGoogle(
          new GoogleUserInfo(
            googleProfile.id,
            googleProfile.email,
            googleProfile.verified_email ?? false, // 3rd arg: Default to false if undefined
            googleProfile.name, // 4th arg: string
            googleProfile.given_name,
            googleProfile.family_name,
            googleProfile.picture,
            googleProfile.locale,
          ),
        );

        // 4. Generate Local JWT Tokens
        // This ensures the frontend gets a token valid for OUR API
        const localTokens = await this.tokenService.generateTokens({
          id: user.id,
          email: user.email.toString(), // Convert Value Object to string
          username: user.username,
          role: user.role,
          planTier: user.planTier || "free", // Add planTier (default to free if missing)
          is_verified: user.isVerified,
          is_active: user.isActive,
          permissions: user.permissions,
          created_at: user.createdAt.toISOString(),
          updated_at: user.updatedAt.toISOString(),
        });

        logger.info("OAuth Login Successful", {
          userId: user.id,
          email: user.email,
        });

        return {
          tokens: localTokens,
          user: googleProfile,
        };
      },
      { retryable: false },
      { operation: "handleCallback" },
    );
  }

  /**
   * Handle Callback with Verifier (PKCE)
   */
  async handleCallbackWithVerifier(
    code: string,
    _codeVerifier: string,
    redirectTo: string,
  ): Promise<{ tokens: AuthTokens; user: GoogleProfile; redirectTo: string }> {
    return this.executeWithEnhancements(
      async () => {
        if (!code) throw new AppError("Code is required", "MISSING_CODE", 400);

        // For now, redirecting to handleCallback logic but allowing for PKCE if needed in future
        const result = await this.handleCallback(code);

        return {
          ...result,
          redirectTo,
        };
      },
      { retryable: false },
      { operation: "handleCallbackWithVerifier" },
    );
  }
}
