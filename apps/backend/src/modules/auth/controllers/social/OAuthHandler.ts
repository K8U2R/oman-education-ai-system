import { Request, Response } from "express";
import { BaseHandler } from "@/presentation/api/handlers/base/BaseHandler.js";
import { logger } from "@/shared/utils/logger.js";
import { InitiateGoogleOAuthUseCase } from "@/application/use-cases/auth/InitiateGoogleOAuthUseCase.js";
import { OAuthStateService } from "@/modules/auth/services/social/OAuthStateService.js";
import { GoogleOAuthService } from "@/modules/auth/services/social/GoogleOAuthService.js";
import { OAuthProviderNotSupportedError } from "@/domain/exceptions/OAuthExceptions.js";
import { ENV_CONFIG } from "@/infrastructure/config/env.config.js";

export class OAuthHandler extends BaseHandler {
    constructor(
        private readonly initiateGoogleOAuthUseCase: InitiateGoogleOAuthUseCase,
        private readonly oauthStateService: OAuthStateService,
        private readonly googleOAuthService: GoogleOAuthService
    ) {
        super();
    }

    /**
     * GET /api/v1/auth/oauth/:provider
     */
    initiateOAuth = async (req: Request, res: Response): Promise<void> => {
        await this.execute(
            res,
            async () => {
                const { provider } = req.params;
                const redirectTo = req.query.redirect_to as string | undefined;

                if (provider !== "google") {
                    throw new OAuthProviderNotSupportedError(
                        `Provider "${provider}" غير مدعوم`,
                    );
                }

                if (!redirectTo) {
                    this.badRequest(res, "redirect_to مطلوب");
                    return;
                }

                const authorizationUrl = await this.initiateGoogleOAuthUseCase.execute(redirectTo);

                res.setHeader(
                    "Cache-Control",
                    "no-store, no-cache, must-revalidate, private",
                );
                res.redirect(authorizationUrl);
            },
            "فشل بدء عملية OAuth",
        );
    };

    /**
     * GET /api/v1/auth/oauth/:provider/callback
     */
    handleOAuthCallback = async (req: Request, res: Response): Promise<void> => {
        try {
            const { provider } = req.params;
            if (provider !== "google")
                throw new OAuthProviderNotSupportedError(
                    `Provider "${provider}" غير مدعوم`,
                );

            if (req.query.error) {
                throw new Error(
                    (req.query.error_description as string) || "فشل عملية OAuth",
                );
            }

            const { code, state } = req.query;

            // Graceful handling for direct access (human users, not Google)
            if (!code || !state) {
                logger.warn('Direct OAuth callback access without code/state', {
                    ip: req.ip,
                    userAgent: req.get('user-agent'),
                    hasReferer: !!req.get('referer'),
                    path: req.originalUrl
                });

                // Redirect to login instead of showing error page
                const frontendUrl = ENV_CONFIG.FRONTEND_URL;
                return res.redirect(
                    `${frontendUrl}/login?message=${encodeURIComponent('يرجى تسجيل الدخول للمتابعة')}`
                );
            }

            const { codeVerifier, redirectTo } =
                await this.oauthStateService.validateAndGetRedirect(state as string);

            // result now contains { tokens: AuthTokens, user: GoogleProfile }
            // The tokens are LOCAL JWTs (access_token, refresh_token) generated by TokenService
            const result = await this.googleOAuthService.handleCallbackWithVerifier(
                code as string,
                codeVerifier,
                redirectTo,
            );

            // Construct redirect URL with LOCAL tokens
            const redirectUrl = new URL(result.redirectTo);
            redirectUrl.searchParams.set("access_token", result.tokens.access_token);
            redirectUrl.searchParams.set("refresh_token", result.tokens.refresh_token);
            redirectUrl.searchParams.set("expires_in", result.tokens.expires_in.toString());

            // Add user info for immediate UI update if needed
            redirectUrl.searchParams.set("user_email", result.user.email);
            redirectUrl.searchParams.set("user_name", result.user.name);

            res.redirect(redirectUrl.toString());
        } catch (error: unknown) {
            const dbError = error as { message: string; stack?: string };
            // Backend Protocol #2: Telemetry
            logger.error('OAuth Failed', {
                provider: 'google',
                error: dbError.message || "Unknown error",
                stack: dbError.stack,
                timestamp: new Date().toISOString()
            });

            // Backend Protocol #1: Silent Defense
            const errorMsg = "oauth_failed";
            const safeReason = "Authentication handshake failed";

            const frontendUrl = ENV_CONFIG.FRONTEND_URL;

            res.redirect(
                `${frontendUrl}/login?error=${encodeURIComponent(errorMsg)}&reason=${encodeURIComponent(safeReason)}`,
            );
        }
    };

    /**
     * POST /api/v1/auth/oauth/exchange-code
     * Frontend-owned OAuth: Exchange code for tokens
     * 
     * Called by OAuthCallbackPage.tsx after receiving code/state from Google
     */
    exchangeOAuthCode = async (req: Request, res: Response): Promise<void> => {
        await this.execute(
            res,
            async () => {
                const { code, state, provider } = req.body;

                if (provider !== "google") {
                    throw new OAuthProviderNotSupportedError(
                        `Provider "${provider}" غير مدعوم`,
                    );
                }

                if (!code || !state) {
                    this.badRequest(res, "code و state مطلوبان");
                    return;
                }

                // Validate state and get redirect URL
                const { codeVerifier, redirectTo } =
                    await this.oauthStateService.validateAndGetRedirect(state as string);

                // Exchange code for tokens
                const result = await this.googleOAuthService.handleCallbackWithVerifier(
                    code as string,
                    codeVerifier,
                    redirectTo,
                );

                // Return JSON response (not redirect!)
                this.ok(res, {
                    success: true,
                    tokens: result.tokens,
                    user: result.user,
                    redirectTo: result.redirectTo
                });
            },
            "فشل تبادل رمز OAuth"
        );
    };
}
